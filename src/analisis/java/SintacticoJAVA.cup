//codigo usuario
package analisis.java;
import java_cup.runtime.Symbol;
import java.util.ArrayList;

//Codigo para el parser, variables, metodos
parser code
{:
    
    
    private Symbol s;
    public void syntaxError(Symbol s){
        this.s = s;
    }
    public Symbol getS(Symbol s){
        return this.s = s;
    }

    public void setAccion(String tipo,String mensaje,String accion){
            System.out.println(tipo+"         "+mensaje);
    }

    public void syntax_error(Symbol s){
            if(s!=null){
                //ErrorG e = new ErrorG(s.right,s.left,(String) s.value,"Sintactico","Error Sintaxis token: "+(String) s.value+" ------ Linea: " + (s.right+1) + ",   Columna: " + (s.left+1));
                //listaErrores.add(e);
                /*Error error = new Error((String) s.value,s.right, s.left, 2, "Error Sintaxis token: "+(String) s.value+" ------ Linea: " + (s.right+1) + ",   Columna: " + (s.left+1));
                erroresSintacticos.add(error);*/
                setAccion("ERROR","Error Sintaxis token: Linea: " + (s.right+1) + ",   Columna: " + (s.left+1) + ",  Simbolo: " + s.value, "");
            }
    }

:}

//Coidgo para las acciones gramaticales

action code
{:
    
:}

//Declaraciones 
terminal SEPARADOR_JAVA, SEPARADOR_PROGRAMA;
terminal CLASS, INT, FLOAT, CHAR, AND, OR, NOT, MAS, MENOS, POR, DIV, MENOR_QUE;
terminal MAYOR_QUE, MENOR_IGUAL, MAYOR_IGUAL, IGUAL, DIFERENTE, COMENTARIO_SIMPLE, COMENTARIO_VARIOS;
terminal SOUT, INTINPUT, FLOATINPUT, CHARINPUT, FOR, WHILE, DO, IF, ELSE, SWITCH;
terminal CASE, BREAK, DEFAULT, VOID, RETURN, PUBLIC, IDENTIFICADOR, DECIMAL;
terminal NUMERO, VALOR, DOS_PUNTOS,CORCHETE_A, CORCHETE_C, LLAVES_A;
terminal LLAVES_C, PUNTO_COMA, COMA, PARENTESIS_A, PARENTESIS_C, MAS_MAS, MENOS_MENOS;
terminal IGUAL_IGUAL, TEXTO;
//terminal ;



// declaracion no terminales
non terminal INICIO, struc_indices, struct_for, codigo, struc_clase, struc_ciclos;
non terminal struct_while, valor_c, valor_n, struc_a, struc_vars, struc_asig_vars_c;
non terminal struc_asig_vars_n, struc_if, struc_else, struc_switch, struc_case;
non terminal valor_case, struc_function, struc_params, params, struc_vars_params;
non terminal valor_condicional, valor, struct_do_while, comentarios;
non terminal struc_condicional, struc_logico, struc_logico_not, vars, valor_m;
non terminal mensaje, valor_comprobacion, codigo_funcion, codigo_inicial, inputs;

//presedencia de menor a mayor
precedence left MAS, MENOS;
precedence left POR, DIV;

start with INICIO;

//Reglas Semanticas

INICIO ::=   SEPARADOR_JAVA codigo_inicial SEPARADOR_PROGRAMA;


codigo_inicial ::=   struc_clase;


codigo ::=   struc_vars codigo
            |struc_function codigo
            |mensaje codigo
            |comentarios codigo
            |;

codigo_funcion ::=   struc_vars codigo_funcion
                    |struc_ciclos codigo_funcion
                    |struc_if codigo_funcion
                    |struc_switch codigo_funcion
                    |mensaje codigo_funcion
                    |inputs codigo_funcion
                    |comentarios codigo_funcion
                    |;

comentarios ::=  COMENTARIO_SIMPLE
                |COMENTARIO_VARIOS;

struc_clase ::=  PUBLIC CLASS IDENTIFICADOR LLAVES_A codigo LLAVES_C struc_clase
                |;

struc_vars ::=   INT struc_asig_vars_n PUNTO_COMA
                |FLOAT struc_asig_vars_n PUNTO_COMA
                |CHAR struc_asig_vars_c PUNTO_COMA
                |IDENTIFICADOR IGUAL valor PUNTO_COMA;

struc_asig_vars_n ::=    IDENTIFICADOR IGUAL valor_n COMA struc_asig_vars_n
                        |IDENTIFICADOR COMA struc_asig_vars_n
                        |IDENTIFICADOR IGUAL valor_n
                        |IDENTIFICADOR;

struc_asig_vars_c ::=    IDENTIFICADOR IGUAL valor_c COMA struc_asig_vars_c
                        |IDENTIFICADOR COMA struc_asig_vars_c
                        |IDENTIFICADOR IGUAL valor_c
                        |IDENTIFICADOR;

struc_ciclos ::= struct_for
                |struct_do_while
                |struct_while;

struct_for ::= FOR PARENTESIS_A struc_indices PARENTESIS_C LLAVES_A codigo_funcion LLAVES_C;

struc_indices ::= IDENTIFICADOR IGUAL valor_n PUNTO_COMA IDENTIFICADOR valor_comprobacion PUNTO_COMA IDENTIFICADOR struc_a;

valor_c ::=  valor_c MAS valor_c
            |valor_c MENOS valor_c
            |valor_c POR valor_c
            |valor_c DIV valor_c
            |PARENTESIS_A valor_c PARENTESIS_C
            |IDENTIFICADOR
            |VALOR
            |NUMERO
            |DECIMAL;

valor_n ::=  valor_n MAS valor_n
            |valor_n MENOS valor_n
            |valor_n POR valor_n
            |valor_n DIV valor_n
            |PARENTESIS_A valor_n PARENTESIS_C
            |IDENTIFICADOR
            |NUMERO
            |DECIMAL;

valor_comprobacion ::=  MENOR_QUE valor_n
            |MAYOR_QUE valor_n
            |MENOR_IGUAL valor_n
            |MAYOR_IGUAL valor_n
            |IGUAL_IGUAL valor_n
            |DIFERENTE valor_n;

struc_a ::=  IGUAL valor_n 
            |MAS_MAS 
            |MENOS_MENOS; 


struct_while ::= WHILE PARENTESIS_A struc_condicional PARENTESIS_C LLAVES_A codigo_funcion LLAVES_C ;

struct_do_while ::= DO LLAVES_A codigo_funcion LLAVES_C WHILE PARENTESIS_A struc_condicional PARENTESIS_C PUNTO_COMA;

valor_condicional ::=    valor MENOR_QUE valor
                        |valor MAYOR_QUE valor
                        |valor MENOR_IGUAL valor
                        |valor MAYOR_IGUAL valor
                        |valor IGUAL_IGUAL valor
                        |valor DIFERENTE valor
                        |PARENTESIS_A valor_condicional PARENTESIS_C;


valor ::=    valor MAS valor
            |valor MENOS valor
            |valor POR valor
            |valor DIV valor
            |PARENTESIS_A valor PARENTESIS_C
            |IDENTIFICADOR
            |VALOR
            |NUMERO
            |DECIMAL;

struc_condicional ::= struc_logico_not  valor_condicional struc_logico;

struc_logico ::= AND struc_logico_not  valor_condicional struc_logico
                |OR struc_logico_not  valor_condicional struc_logico
                | ;

struc_logico_not ::= NOT
                    |;

struc_if ::= IF PARENTESIS_A struc_condicional PARENTESIS_C LLAVES_A codigo_funcion LLAVES_C struc_else ;

struc_else ::=   ELSE IF PARENTESIS_A struc_condicional PARENTESIS_C LLAVES_A codigo_funcion LLAVES_C struc_else
                |ELSE LLAVES_A codigo_funcion LLAVES_C
                | ;

struc_switch ::= SWITCH PARENTESIS_A IDENTIFICADOR PARENTESIS_C LLAVES_A struc_case LLAVES_C;

struc_case ::=   CASE valor_case DOS_PUNTOS codigo_funcion BREAK PUNTO_COMA struc_case
                |CASE valor_case DOS_PUNTOS codigo_funcion BREAK PUNTO_COMA
                |DEFAULT DOS_PUNTOS codigo_funcion;

valor_case ::=   VALOR
                |NUMERO
                |DECIMAL;

struc_function ::=  PUBLIC VOID IDENTIFICADOR PARENTESIS_A struc_params PARENTESIS_C LLAVES_A codigo_funcion LLAVES_C
                   |PUBLIC vars IDENTIFICADOR PARENTESIS_A struc_params PARENTESIS_C LLAVES_A codigo_funcion RETURN valor PUNTO_COMA LLAVES_C ;

struc_params ::= struc_vars_params params
                |;

params ::=   COMA struc_vars_params params
            |;

struc_vars_params ::=    INT IDENTIFICADOR
                        |FLOAT IDENTIFICADOR
                        |CHAR IDENTIFICADOR;

vars ::=     INT
            |FLOAT
            |CHAR;

mensaje ::= SOUT valor_m PARENTESIS_C PUNTO_COMA;

valor_m ::=  valor_m MAS valor_m
            |valor_m MENOS valor_m
            |valor_m POR valor_m
            |valor_m DIV valor_m
            |PARENTESIS_A valor_m PARENTESIS_C
            |IDENTIFICADOR
            |TEXTO
            |VALOR
            |NUMERO
            |DECIMAL;

inputs ::=   CHARINPUT
            |FLOATINPUT
            |INTINPUT;

