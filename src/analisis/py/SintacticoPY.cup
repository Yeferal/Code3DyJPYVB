//codigo usuario
package analisis.py;
import comprobaciones.ComprobadorAmbito;
import comprobaciones.ComprobadorTipos;
import java_cup.runtime.Symbol;
import java.util.ArrayList;
import simbolos.Simbolo;
import simbolos.TablaSimbolos;
import errores.ErrorG;

//Codigo para el parser, variables, metodos
parser code
{:
    public TablaSimbolos tablaSimbolos = new TablaSimbolos();
    public ArrayList<ErrorG> erroresSemanticos = new ArrayList<>();
    
    private Symbol s;
    public void syntaxError(Symbol s){
        this.s = s;
    }
    public Symbol getS(Symbol s){
        return this.s = s;
    }

    public void setAccion(String tipo,String mensaje,String accion){
            System.out.println(tipo+"         "+mensaje);
    }

    public void syntax_error(Symbol s){
            if(s!=null){
                //ErrorG e = new ErrorG(s.right,s.left,(String) s.value,"Sintactico","Error Sintaxis token: "+(String) s.value+" ------ Linea: " + (s.right+1) + ",   Columna: " + (s.left+1));
                //listaErrores.add(e);
                /*Error error = new Error((String) s.value,s.right, s.left, 2, "Error Sintaxis token: "+(String) s.value+" ------ Linea: " + (s.right+1) + ",   Columna: " + (s.left+1));
                erroresSintacticos.add(error);*/
                setAccion("ERROR","Error Sintaxis token: Linea: " + (s.right+1) + ",   Columna: " + (s.left+1) + ",  Simbolo: " + s.value, "");
            }
    }

:}

//Coidgo para las acciones gramaticales

action code
{:
    ComprobadorTipos comprobadorTipos = new ComprobadorTipos();
    ComprobadorAmbito comprobadorAmbito = new ComprobadorAmbito();
    ArrayList<ErrorG> erroresSemanticos = new ArrayList<>();
    int ambitoFlag = 0;
    int ambitoContador = 0;
    int ambitoActual = 0;
    String tipoV = "";
    ArrayList<Integer> ambitos = new ArrayList<>();
    TablaSimbolos tablaSimbolos = new TablaSimbolos();

    public void actualizarAmbitos(){
        ambitoFlag = comprobadorAmbito.getAmbitoBandera();
        ambitoActual = comprobadorAmbito.getAmbitoPivote();
    }
:}

//Declaraciones 
terminal SEPARADOR_PY, SEPARADOR_PROGRAMA, AND, OR, NOT, MAS, MENOS, POT, POR;
terminal DIV_ENTERA, DIV, MENOR_QUE, MAYOR_QUE, MENOR_IGUAL, MAYOR_IGUAL, DIV_ENTERO;
terminal IGUAL_IGUAL, DIFERENTE, COMENTARIO_SIMPLE, COMENTARIO_VARIOS, PRINT;
terminal INTINPUT, FLOATINPUT, CHARINPUT, FOR, IN, GUION_BAJO, WHILE, IF, ELSE;
terminal ELSE_IF, BREAK, DEF, RETURN, IDENTIFICADOR, NUMERO, VALOR, TEXTO, SALTO;
terminal TAB, IGUAL, DOS_PUNTOS, CORCHETE_A, CORCHETE_C, LLAVES_A, LLAVES_C;
terminal COMA, PARENTESIS_A, PARENTESIS_C;
//terminal ;



// declaracion no terminales
non terminal INICIO, declaracion_var, codigo, valor, funcion, codigo_def, tabs;
non terminal ciclos, struct_for, datos_for, dato, mas_datos, struct_while, retunr_v;
non terminal condicion, condiciones, pre, not, condicionales, struc_if, solicitud;
non terminal mensajes, parametros, params, codigo_inicio, val, valor_tipo, comentarios;
//non terminal ;

//presedencia de menor a mayor
precedence left MAS, MENOS, COMA;
precedence left POR, DIV, DIV_ENTERO;
precedence left POT;

start with INICIO;

//Reglas Semanticas

INICIO ::=   SEPARADOR_PY {:actualizarAmbitos();:} codigo_inicio SEPARADOR_PROGRAMA {:parser.tablaSimbolos = tablaSimbolos; parser.erroresSemanticos = erroresSemanticos;:};

declaracion_var ::= IDENTIFICADOR:a {:
                    if(ambitoContador==0){
                        erroresSemanticos.add(new ErrorG((String)a,aright+1,aleft+1,2,"Error de identacion, unicamente las Funciones no pueden tener tabulacion"));
                    }/*else{
                        comprobadorAmbito.verificarAmbito(ambitoFlag,ambitoActual,ambitoContador);actualizarAmbitos();
                    }*/
                :} IGUAL valor_tipo:b SALTO {:
                    if(b!=null){
                        if(tablaSimbolos.isExistSimboloJ(comprobadorAmbito.ambitosCamino, (String) a)){
                            
                            switch(comprobadorTipos.getValorTipo(b)){
                                case 1:
                                    tablaSimbolos.setSimboloPY(b,"Integer");
                                    break;
                                case 2:
                                    tablaSimbolos.setSimboloPY(b,"Float");
                                    break;
                                case 3:
                                    tablaSimbolos.setSimboloPY(b,"Char");
                                    break;
                            }
                        }else{
                            switch(comprobadorTipos.getValorTipo(b)){
                                case 1:
                                    Simbolo s = new Simbolo((String)a,"Integer",ambitoActual,b);
                                    tablaSimbolos.agregarSimbolo(s);
                                    break;
                                case 2:
                                    Simbolo s1 = new Simbolo((String)a,"Float",ambitoActual,b);
                                    tablaSimbolos.agregarSimbolo(s1);
                                    break;
                                case 3:
                                    Simbolo s2 = new Simbolo((String)a,"Char",ambitoActual,b);
                                    tablaSimbolos.agregarSimbolo(s2);
                                    break;
                            }
                            
                        }
                    }
                :};

valor_tipo ::= valor:a {:RESULT = a;:}
                |solicitud:a {:RESULT = a;:};

codigo_inicio ::= tabs:a {:ambitoContador = (int)a; System.out.println("Tabs: "+(int)a);:} codigo
                |;

codigo ::=   funcion codigo_inicio
            |declaracion_var codigo_inicio
            |ciclos codigo_inicio
            |condicionales codigo_inicio
            |comentarios codigo_inicio
            |mensajes codigo_inicio
            |retunr_v codigo_inicio
            |solicitud SALTO codigo_inicio
            |SALTO codigo_inicio;

retunr_v ::= RETURN valor SALTO;

valor ::=    valor:a MAS valor:b {:
                        if(a!=null && b!=null){
                            if(comprobadorTipos.isNumero(a) && comprobadorTipos.isNumero(b)){
                                if(comprobadorTipos.isInteger(a) && comprobadorTipos.isInteger(b)){
                                    int resultado = (int) ((int)a+(int)b); RESULT = resultado;
                                }else{float resultado = (float) ((float)comprobadorTipos.convertirFlotante(a)+(float)comprobadorTipos.convertirFlotante(b)); RESULT = resultado;}
                            }else{
                                String texto = a +""+ b; RESULT = texto;
                            }
                        }else{RESULT = null;}
                :}
            |valor:a COMA valor:b {:
                        if(a!=null && b!=null){
                            String texto = a +""+b; RESULT = texto;
                        }else{RESULT = null;}
                :}
            |valor:a MENOS:c valor:b {:
                        if(a!=null && b!=null){
                            if(comprobadorTipos.isNumero(a) && comprobadorTipos.isNumero(b)){
                                if(comprobadorTipos.isInteger(a) && comprobadorTipos.isInteger(b)){
                                    int resultado = (int) ((int)a-(int)b); RESULT = resultado;
                                }else{float resultado = (float) ((float)comprobadorTipos.convertirFlotante(a)-(float)comprobadorTipos.convertirFlotante(b)); RESULT = resultado;}
                            }else{
                                if(comprobadorTipos.isNumero(a)){
                                    erroresSemanticos.add(new ErrorG((String)c,cright+1,cleft+1,3,"La operacion no es valida")); RESULT = null;
                                }else{erroresSemanticos.add(new ErrorG((String)c,cright+1,cleft+1,3,"La operacion no es valida")); RESULT = null;}
                            }
                        }else{RESULT = null;}
                :}
            |valor:a POR:c valor:b {:
                        if(a!=null && b!=null){
                            if(comprobadorTipos.isNumero(a) && comprobadorTipos.isNumero(b)){
                                if(comprobadorTipos.isFloat(a) || comprobadorTipos.isFloat(b)){
                                    float resultado = (float) ((float)comprobadorTipos.convertirFlotante(a)*(float)comprobadorTipos.convertirFlotante(b)); RESULT = resultado;
                                }else{int resultado = (int) ((int)a*(int)b); RESULT = resultado;}
                            }else{
                                if(comprobadorTipos.isNumero(a)){
                                    erroresSemanticos.add(new ErrorG((String)c,cright+1,cleft+1,3,"La operacion no es valida")); RESULT = null;
                                }else{erroresSemanticos.add(new ErrorG((String)c,cright+1,cleft+1,3,"La operacion no es valida")); RESULT = null;}
                            }
                        }else{RESULT = null;}
                :}
            |valor:a DIV:c valor:b {:
                        if(a!=null && b!=null){
                            if(comprobadorTipos.isNumero(a) && comprobadorTipos.isNumero(b)){
                                if(comprobadorTipos.isFloat(a) || comprobadorTipos.isFloat(b)){
                                    float resultado = (float) ((float)comprobadorTipos.convertirFlotante(a)/(float)comprobadorTipos.convertirFlotante(b)); RESULT = resultado;
                                }else{Object resultado = comprobadorTipos.tiparObjeto((int)a/(int)b); RESULT = resultado;}
                            }else{
                                if(comprobadorTipos.isNumero(a)){
                                    erroresSemanticos.add(new ErrorG((String)c,cright+1,cleft+1,3,"La operacion no es valida")); RESULT = null;
                                }else{erroresSemanticos.add(new ErrorG((String)c,cright+1,cleft+1,3,"La operacion no es valida")); RESULT = null;}
                            }
                        }else{RESULT = null;}
                :}
            |valor:a DIV_ENTERO:c valor:b {:
                        if(a!=null && b!=null){
                            if(comprobadorTipos.isNumero(a) && comprobadorTipos.isNumero(b)){
                                int resultado = (int) ((float)a/(float)b);
                                RESULT = resultado;
                            }else{
                                if(comprobadorTipos.isNumero(a)){
                                    erroresSemanticos.add(new ErrorG((String)c,cright+1,cleft+1,3,"La operacion no es valida")); RESULT = null;
                                }else{erroresSemanticos.add(new ErrorG((String)c,cright+1,cleft+1,3,"La operacion no es valida")); RESULT = null;}
                            }
                        }else{RESULT = null;}
                :}
            |valor:a POT valor:b {:RESULT = a;:}
            |PARENTESIS_A valor:a PARENTESIS_C {:RESULT = a;:}
            |IDENTIFICADOR:a {:
                            if(tablaSimbolos.isExistSimbolo(comprobadorAmbito.ambitosCamino, (String) a)){
                                RESULT = tablaSimbolos.getSimboloValor();
                            }else{erroresSemanticos.add(new ErrorG((String)a,aright+1,aleft+1,3,"La Varaible \""+(String)a+"\" no ha sido declarada dentro del ambito")); RESULT = null;}
                :}
            |VALOR:a {:RESULT = a;:}
            |TEXTO:a {:RESULT = a;:}
            |NUMERO:a {:RESULT = a;:}; 

funcion ::= DEF:a {:
                    if(ambitoContador>0){
                        erroresSemanticos.add(new ErrorG("DEF",aright+1,aleft+1,2,"Error de identacion, los funciones no deben de tener Tabulacion"));
                    }else{
                        comprobadorAmbito.verificarAmbito(ambitoFlag,ambitoActual,ambitoContador);actualizarAmbitos();
                    }
            :} IDENTIFICADOR PARENTESIS_A parametros PARENTESIS_C DOS_PUNTOS SALTO;
                        
parametros ::=   IDENTIFICADOR:a {:
                            switch(comprobadorTipos.getValorTipo(0)){
                                case 1:
                                    Simbolo s = new Simbolo((String)a,"Integer",ambitoActual,0);
                                    tablaSimbolos.agregarSimbolo(s);
                                    break;
                                case 2:
                                    Simbolo s1 = new Simbolo((String)a,"Float",ambitoActual,0);
                                    tablaSimbolos.agregarSimbolo(s1);
                                    break;
                                case 3:
                                    Simbolo s2 = new Simbolo((String)a,"Char",ambitoActual,'c');
                                    tablaSimbolos.agregarSimbolo(s2);
                                    break;
                            }:} params
                |;

params ::=   COMA IDENTIFICADOR:a {:
                        if(tablaSimbolos.isExistSimboloJ(comprobadorAmbito.ambitosCamino, (String) a)){
                            
                            switch(comprobadorTipos.getValorTipo(0)){
                                case 1:
                                    tablaSimbolos.setSimboloPY(0,"Integer");
                                    break;
                                case 2:
                                    tablaSimbolos.setSimboloPY(0,"Float");
                                    break;
                                case 3:
                                    tablaSimbolos.setSimboloPY(0,"Char");
                                    break;
                            }
                        }else{
                            switch(comprobadorTipos.getValorTipo(0)){
                                case 1:
                                    Simbolo s = new Simbolo((String)a,"Integer",ambitoActual,0);
                                    tablaSimbolos.agregarSimbolo(s);
                                    break;
                                case 2:
                                    Simbolo s1 = new Simbolo((String)a,"Float",ambitoActual,0);
                                    tablaSimbolos.agregarSimbolo(s1);
                                    break;
                                case 3:
                                    Simbolo s2 = new Simbolo((String)a,"Char",ambitoActual,'c');
                                    tablaSimbolos.agregarSimbolo(s2);
                                    break;
                            }
                        }
                        :}
            |;

codigo_def ::= declaracion_var;

tabs ::= TAB tabs:a {:RESULT = 1+(int) a;:}
        |{:RESULT = 0;:};

ciclos ::=   struct_for
            |struct_while;

struct_for ::=   FOR:a {:
                    if(ambitoContador==0){
                        erroresSemanticos.add(new ErrorG((String)a,aright+1,aleft+1,2,"Error de identacion, unicamente las Funciones no pueden tener tabulacion"));
                    }
                :} IDENTIFICADOR:b {:
                            switch(comprobadorTipos.getValorTipo(0)){
                                case 1:
                                    Simbolo s = new Simbolo((String)b,"Integer",ambitoActual,0);
                                    tablaSimbolos.agregarSimbolo(s);
                                    break;
                                case 2:
                                    Simbolo s1 = new Simbolo((String)b,"Float",ambitoActual,0);
                                    tablaSimbolos.agregarSimbolo(s1);
                                    break;
                                case 3:
                                    Simbolo s2 = new Simbolo((String)b,"Char",ambitoActual,0);
                                    tablaSimbolos.agregarSimbolo(s2);
                                    break;
                            }:} IN datos_for DOS_PUNTOS SALTO
                |FOR:a {:
                    if(ambitoContador==0){
                        erroresSemanticos.add(new ErrorG("DEF",aright+1,aleft+1,2,"Error de identacion, loa funciones no deben de tener Tabulacion"));
                    }
                :} GUION_BAJO IN datos_for DOS_PUNTOS SALTO;

datos_for ::=    TEXTO
                |NUMERO
                |CORCHETE_A dato mas_datos CORCHETE_C;

dato ::= TEXTO
        |NUMERO;

mas_datos ::= COMA dato mas_datos
            | ;

struct_while ::= WHILE:a {:
                    if(ambitoContador==0){
                        erroresSemanticos.add(new ErrorG((String)a,aright+1,aleft+1,2,"Error de identacion, unicamente las Funciones no pueden tener tabulacion"));
                    }
                :} condicion DOS_PUNTOS SALTO;


condicion ::= not condiciones pre;

condiciones ::=  valor MENOR_QUE valor
                |valor MAYOR_QUE valor
                |valor MENOR_IGUAL valor
                |valor MAYOR_IGUAL valor
                |valor IGUAL_IGUAL valor
                |valor DIFERENTE valor
                |PARENTESIS_A condiciones PARENTESIS_C;

pre ::= AND not condiciones pre
        |OR not condiciones pre
        |;

not ::=  NOT 
        |;

condicionales ::= struc_if;

struc_if ::= IF:a {:
                    if(ambitoContador==0){
                        erroresSemanticos.add(new ErrorG((String)a,aright+1,aleft+1,2,"Error de identacion, unicamente las Funciones no pueden tener tabulacion"));
                    }
                :} condicion DOS_PUNTOS SALTO
            |ELSE_IF:a {:
                    if(ambitoContador==0){
                        erroresSemanticos.add(new ErrorG((String)a,aright+1,aleft+1,2,"Error de identacion, unicamente las Funciones no pueden tener tabulacion"));
                    }
                :} condicion DOS_PUNTOS SALTO
            |ELSE:a {:
                    if(ambitoContador==0){
                        erroresSemanticos.add(new ErrorG((String)a,aright+1,aleft+1,2,"Error de identacion, unicamente las Funciones no pueden tener tabulacion"));
                    }
                :};

mensajes ::= PRINT:a {:
                    if(ambitoContador==0){
                        erroresSemanticos.add(new ErrorG((String)a,aright+1,aleft+1,2,"Error de identacion, unicamente las Funciones no pueden tener tabulacion"));
                    }
                :} val PARENTESIS_C SALTO;

solicitud ::=    INTINPUT:a {:
                    if(ambitoContador==0){
                        erroresSemanticos.add(new ErrorG((String)a,aright+1,aleft+1,2,"Error de identacion, unicamente las Funciones no pueden tener tabulacion"));
                    }
                :} PARENTESIS_A val PARENTESIS_C {:RESULT = (int)0;:}
                |FLOATINPUT:a {:
                    if(ambitoContador==0){
                        erroresSemanticos.add(new ErrorG((String)a,aright+1,aleft+1,2,"Error de identacion, unicamente las Funciones no pueden tener tabulacion"));
                    }
                :} PARENTESIS_A val PARENTESIS_C {:RESULT = (float)0.0;:}
                |CHARINPUT:a {:
                    if(ambitoContador==0){
                        erroresSemanticos.add(new ErrorG((String)a,aright+1,aleft+1,2,"Error de identacion, unicamente las Funciones no pueden tener tabulacion"));
                    }/*else{
                        comprobadorAmbito.verificarAmbito(ambitoFlag,ambitoActual,ambitoContador);actualizarAmbitos();
                    }*/
                :} PARENTESIS_A val PARENTESIS_C {:RESULT = (char)'c';:};

val ::= valor
        |;

comentarios ::=  COMENTARIO_SIMPLE
                |COMENTARIO_VARIOS;

